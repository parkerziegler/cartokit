import { json, error } from '@sveltejs/kit';
import OpenAI from 'openai';
import { zodResponseFormat } from 'openai/helpers/zod';
import { z } from 'zod';

import { OPENAI_API_KEY } from '$env/static/private';
import type { RequestHandler } from './$types';

import { connectToMongoDB } from '$lib/db';
import type { LayerType } from '$lib/types';

interface PromptDoc {
  userId: string;
  prompt: string;
  diffs: unknown[];
  timestamp: string;
}

const openai = new OpenAI({
  apiKey: OPENAI_API_KEY!
});

/**
 * Persist the user's prompt and the diffs generated by the OpenAI API to
 * MongoDB for later analysis.
 *
 * @param userId – The ID of the user who made the request.
 * @param prompt – The user's prompt, sent to the OpenAI API.
 * @param diffs – The array of diffs generated by the OpenAI API.
 * @returns – The document that was saved to MongoDB.
 */
async function savePrompt(
  userId: string,
  prompt: string,
  diffs: unknown[]
): Promise<PromptDoc> {
  const db = connectToMongoDB();
  const collection = db.collection('prompts');

  const doc = {
    userId,
    prompt,
    diffs,
    timestamp: new Date().toISOString()
  };

  try {
    await collection.insertOne(doc);

    return doc;
  } catch (error) {
    throw new Error(`Failed to save prompt: ${error}`);
  }
}

/**
 * The main function that handles the POST request to the /llm endpoint. This
 * function receives a prompt from a user and sends it to the OpenAI API, re-
 * turning the generated diffs as a JSON response. In addition, we save off
 * the prompt and diffs to MongoDB for later analysis.
 */
export const POST = (async ({ request }) => {
  const { prompt, layerIds, layerIdsToAttributes, userId } =
    await request.json();

  try {
    const completion = await openai.beta.chat.completions.parse({
      model: 'gpt-4o',
      messages: [
        {
          role: 'system',
          content:
            'Generate zero or more updates to the map visualization. Choose the "unknown" update if you cannot easily determine the type of update based on the prompt.'
        },
        { role: 'user', content: prompt }
      ],
      response_format: zodResponseFormat(
        makeSchema(layerIds, layerIdsToAttributes),
        'diffs'
      )
    });

    const result = completion.choices[0].message.parsed;

    if (result) {
      const diffs = result.diffs;

      await savePrompt(userId, prompt, diffs);
    }

    return json(result);
  } catch (err) {
    console.error(err);

    return error(500, {
      message: 'Internal server error'
    });
  }
}) satisfies RequestHandler;

/**
 * Construct the schema for the layerId field for a diff object. We want con-
 * strained decoding responses from the OpenAI API to only target existing
 * layers on the map.
 *
 * @param layerIds – An array of the current layer IDs on the map.
 * @returns – A Zod schema for the layerId field in a diff object.
 */
function makeLayerIdSchema(layerIds: string[]) {
  return layerIds.length > 1
    ? z.union([
        z.literal(layerIds[0]),
        z.literal(layerIds[1]),
        ...layerIds.slice(2).map((id) => z.literal(id))
      ])
    : z.literal(layerIds[0]);
}

const LayerType = z.union([
  z.literal('Point'),
  z.literal('Proportional Symbol'),
  z.literal('Line'),
  z.literal('Polygon'),
  z.literal('Choropleth'),
  z.literal('Dot Density')
]);

function LayerTypeUpdate(layerIds: string[]) {
  return z.object({
    type: z.literal('layer-type'),
    layerId: makeLayerIdSchema(layerIds),
    payload: z.object({
      layerType: LayerType
    })
  });
}

function AttributeUpdate(
  layerIds: string[],
  layerIdsToAttributes: Record<string, string[]>
) {
  const attrs = Object.values(layerIdsToAttributes).flat();

  return z.object({
    type: z.literal('attribute'),
    layerId: makeLayerIdSchema(layerIds),
    payload: z.object({
      attribute: z.union([
        z.literal(attrs[0]),
        z.literal(attrs[1]),
        ...attrs.slice(2).map((attr) => z.literal(attr))
      ]),
      channel: z.union([z.literal('fill'), z.literal('size')])
    })
  });
}

function FillUpdate(layerIds: string[]) {
  return z.object({
    type: z.literal('fill'),
    layerId: makeLayerIdSchema(layerIds),
    payload: z.object({
      color: z.string()
    })
  });
}

function FillOpacityUpdate(layerIds: string[]) {
  return z.object({
    type: z.literal('fill-opacity'),
    layerId: makeLayerIdSchema(layerIds),
    payload: z.object({
      opacity: z.number()
    })
  });
}

function AddFillUpdate(layerIds: string[]) {
  return z.object({
    type: z.literal('add-fill'),
    layerId: makeLayerIdSchema(layerIds),
    payload: z.object({})
  });
}

function RemoveFillUpdate(layerIds: string[]) {
  return z.object({
    type: z.literal('remove-fill'),
    layerId: makeLayerIdSchema(layerIds),
    payload: z.object({})
  });
}

function StrokeUpdate(layerIds: string[]) {
  return z.object({
    type: z.literal('stroke'),
    layerId: makeLayerIdSchema(layerIds),
    payload: z.object({
      width: z.number(),
      color: z.string()
    })
  });
}

function StrokeWidthUpdate(layerIds: string[]) {
  return z.object({
    type: z.literal('stroke-width'),
    layerId: makeLayerIdSchema(layerIds),
    payload: z.object({
      strokeWidth: z.number()
    })
  });
}

function StrokeOpacityUpdate(layerIds: string[]) {
  return z.object({
    type: z.literal('stroke-opacity'),
    layerId: makeLayerIdSchema(layerIds),
    payload: z.object({
      opacity: z.number()
    })
  });
}

function AddStrokeUpdate(layerIds: string[]) {
  return z.object({
    type: z.literal('add-stroke'),
    layerId: makeLayerIdSchema(layerIds),
    payload: z.object({})
  });
}

function RemoveStrokeUpdate(layerIds: string[]) {
  return z.object({
    type: z.literal('remove-stroke'),
    layerId: makeLayerIdSchema(layerIds),
    payload: z.object({})
  });
}

function PointSizeUpdate(layerIds: string[]) {
  return z.object({
    type: z.literal('point-size'),
    layerId: makeLayerIdSchema(layerIds),
    payload: z.object({
      size: z.number()
    })
  });
}

const ClassificationMethod = z.union([
  z.literal('Quantile'),
  z.literal('Equal Interval'),
  z.literal('Jenks'),
  z.literal('Manual')
]);

function ClassificationMethodUpdate(layerIds: string[]) {
  return z.object({
    type: z.literal('classification-method'),
    layerId: makeLayerIdSchema(layerIds),
    payload: z.object({
      method: ClassificationMethod
    })
  });
}

function ColorSchemeUpdate(layerIds: string[]) {
  return z.object({
    type: z.literal('color-scheme'),
    layerId: makeLayerIdSchema(layerIds),
    payload: z.object({
      scheme: z.union([
        z.literal('schemeBlues'),
        z.literal('schemeGreens'),
        z.literal('schemeGreys'),
        z.literal('schemeOranges'),
        z.literal('schemePurples'),
        z.literal('schemeReds'),
        z.literal('schemeBuGn'),
        z.literal('schemeBuPu'),
        z.literal('schemeGnBu'),
        z.literal('schemeOrRd'),
        z.literal('schemePuBuGn'),
        z.literal('schemePuBu'),
        z.literal('schemePuRd'),
        z.literal('schemeRdPu'),
        z.literal('schemeYlGnBu'),
        z.literal('schemeYlGn'),
        z.literal('schemeYlOrBr'),
        z.literal('schemeYlOrRd'),
        z.literal('schemeBrBG'),
        z.literal('schemePRGn'),
        z.literal('schemePiYG'),
        z.literal('schemePuOr'),
        z.literal('schemeRdBu'),
        z.literal('schemeRdGy'),
        z.literal('schemeRdYlBu'),
        z.literal('schemeRdYlGn'),
        z.literal('schemeSpectral'),
        z.literal('schemeCategory10'),
        z.literal('schemeAccent'),
        z.literal('schemeDark2'),
        z.literal('schemeObservable10'),
        z.literal('schemePaired'),
        z.literal('schemePastel1'),
        z.literal('schemePastel2'),
        z.literal('schemeSet1'),
        z.literal('schemeSet2'),
        z.literal('schemeSet3'),
        z.literal('schemeTableau10')
      ])
    })
  });
}

function ColorSchemeDirectionUpdate(layerIds: string[]) {
  return z.object({
    type: z.literal('color-scheme-direction'),
    layerId: makeLayerIdSchema(layerIds),
    payload: z.object({
      direction: z.union([z.literal('Forward'), z.literal('Reverse')])
    })
  });
}

function ColorCountUpdate(layerIds: string[]) {
  return z.object({
    type: z.literal('color-count'),
    layerId: makeLayerIdSchema(layerIds),
    payload: z.object({
      count: z.number()
    })
  });
}

function ColorThresholdUpdate(layerIds: string[]) {
  return z.object({
    type: z.literal('color-threshold'),
    layerId: makeLayerIdSchema(layerIds),
    payload: z.object({
      index: z.number(),
      threshold: z.number()
    })
  });
}

function SizeUpdate(layerIds: string[]) {
  return z.object({
    type: z.literal('size'),
    layerId: makeLayerIdSchema(layerIds),
    payload: z.object({
      min: z.optional(z.number()),
      max: z.optional(z.number())
    })
  });
}

function DotValueUpdate(layerIds: string[]) {
  return z.object({
    type: z.literal('dots'),
    layerId: makeLayerIdSchema(layerIds),
    payload: z.object({
      value: z.number()
    })
  });
}

const VisualizationType = z.union([
  z.literal('Quantitative'),
  z.literal('Categorical'),
  z.literal('Constant')
]);

function VisualizationTypeUpdate(layerIds: string[]) {
  return z.object({
    type: z.literal('visualization-type'),
    layerId: makeLayerIdSchema(layerIds),
    payload: z.object({
      visualizationType: VisualizationType
    })
  });
}

function UnknownUpdate(layerIds: string[]) {
  return z.object({
    type: z.literal('unknown'),
    layerId: makeLayerIdSchema(layerIds),
    payload: z.object({})
  });
}

function makeSchema(
  layerIds: string[],
  layerIdsToAttributes: Record<string, string[]>
) {
  return z.object({
    diffs: z.array(
      z.discriminatedUnion('type', [
        LayerTypeUpdate(layerIds),
        AttributeUpdate(layerIds, layerIdsToAttributes),
        FillUpdate(layerIds),
        FillOpacityUpdate(layerIds),
        AddFillUpdate(layerIds),
        RemoveFillUpdate(layerIds),
        StrokeUpdate(layerIds),
        StrokeWidthUpdate(layerIds),
        StrokeOpacityUpdate(layerIds),
        AddStrokeUpdate(layerIds),
        RemoveStrokeUpdate(layerIds),
        PointSizeUpdate(layerIds),
        ClassificationMethodUpdate(layerIds),
        ColorSchemeUpdate(layerIds),
        ColorSchemeDirectionUpdate(layerIds),
        ColorCountUpdate(layerIds),
        ColorThresholdUpdate(layerIds),
        SizeUpdate(layerIds),
        DotValueUpdate(layerIds),
        VisualizationTypeUpdate(layerIds),
        UnknownUpdate(layerIds)
      ])
    )
  });
}
