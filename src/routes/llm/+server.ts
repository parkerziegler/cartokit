import { json, error } from '@sveltejs/kit';
import OpenAI from 'openai';
import type { ChatCompletionParseParams } from 'openai/resources/chat/completions';
import { z } from 'zod';

import { OPENAI_API_KEY } from '$env/static/private';
import type { RequestHandler } from './$types';

import { connectToMongoDB } from '$lib/db';
import type { BasemapProvider, LayerType } from '$lib/types';
import { BASEMAPS, TILE_URLS } from '$lib/utils/basemap';

interface PromptDoc {
  userId: string;
  prompt: string;
  diffs: unknown[];
  timestamp: string;
}

/**
 * Persist the user's prompt and the diffs generated by the OpenAI API to
 * MongoDB for later analysis.
 *
 * @param userId – The ID of the user who made the request.
 * @param prompt – The user's prompt, sent to the OpenAI API.
 * @param diffs – The array of diffs generated by the OpenAI API.
 * @returns – The document that was saved to MongoDB.
 */
async function savePrompt(
  userId: string,
  prompt: string,
  diffs: unknown[]
): Promise<PromptDoc> {
  const db = connectToMongoDB();
  const collection = db.collection('prompts');

  const doc = {
    userId,
    prompt,
    diffs,
    timestamp: new Date().toISOString()
  };

  try {
    await collection.insertOne(doc);

    return doc;
  } catch (error) {
    throw new Error(`Failed to save prompt: ${error}`);
  }
}

// Initialize the OpenAI client.
const openai = new OpenAI({
  apiKey: OPENAI_API_KEY!
});

/**
 * The main function that handles the POST request to the /llm endpoint. This
 * function receives a prompt from a user and sends it to the OpenAI API, re-
 * turning the generated diffs as a JSON response. In addition, we save off
 * the prompt and diffs to MongoDB for later analysis.
 */
export const POST = (async ({ request }) => {
  const { prompt, layerIds, layerIdsToTypes, layerIdsToAttributes, userId } =
    await request.json();

  const schema = makeSchema(layerIds, layerIdsToAttributes);

  try {
    const completion = await openai.chat.completions.parse<
      ChatCompletionParseParams,
      z.infer<typeof schema>
    >({
      model: 'gpt-5',
      messages: [
        {
          role: 'system',
          content: `Generate zero or more diffs to apply to the map visualization
          based on the user's prompt. Choose the "unknown" diff if you cannot
          easily determine the type of diff based on the prompt.
            
          When creating new layers with "add-layer", generate friendly layer IDs
          in kebab-case format with a unqiue hash suffix based on the
          displayName (e.g., "population-data__a1b2c3" for a layer named
          "Population Data"). Use the same layer ID when referencing the newly
          created layer in subsequent diffs within the same request, as
          appropriate.
          
          When transitioning a layer's type with "layer-type", consult the
          following dictionary to determine the current sourceLayerType for the
          layer targeted by the diff: ${JSON.stringify(layerIdsToTypes)}.`
        },
        { role: 'user', content: prompt }
      ],
      response_format: {
        type: 'json_schema',
        json_schema: {
          name: 'diffs',
          strict: true,
          schema: z.toJSONSchema(schema, {
            target: 'draft-7'
          })
        }
      }
    });

    const result = completion.choices[0].message.parsed;

    if (result) {
      const diffs = result.diffs;

      await savePrompt(userId, prompt, diffs);
    }

    return json(result);
  } catch (err) {
    console.error(err);

    return error(500, {
      message: 'Internal server error'
    });
  }
}) satisfies RequestHandler;

/**
 * Construct the schema for the layerId field for a diff object. We want con-
 * strained decoding responses from the OpenAI API to only target existing
 * layers on the map.
 *
 * @param layerIds – An array of the current layer IDs on the map.
 * @returns – A Zod schema for the layerId field in a diff object.
 */
function makeLayerIdSchema(layerIds: string[]) {
  const freshLayerIdSchema = z
    .string()
    .regex(/^[a-z0-9]+(?:-[a-z0-9]+)*__[a-z0-9]+$/);

  if (layerIds.length === 0) {
    return freshLayerIdSchema;
  }

  return z.union([
    z.literal(layerIds[0]),
    freshLayerIdSchema,
    ...layerIds.slice(1).map((id) => z.literal(id))
  ]);
}

function makeAttrsSchema(layerIdsToAttributes: Record<string, string[]>) {
  const attrs = Object.values(layerIdsToAttributes).flat();

  switch (attrs.length) {
    case 0:
      return z.literal('None');
    case 1:
      return z.literal(attrs[0]);
    default:
      return z.union([
        z.literal(attrs[0]),
        z.literal(attrs[1]),
        ...attrs.slice(2).map((attr) => z.literal(attr))
      ]);
  }
}

const LayerType = z.union([
  z.literal('Choropleth'),
  z.literal('Dot Density'),
  z.literal('Heatmap'),
  z.literal('Line'),
  z.literal('Point'),
  z.literal('Polygon'),
  z.literal('Proportional Symbol')
]);

function LayerTypeDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('layer-type'),
    layerId: layerIdSchema,
    payload: z.object({
      sourceLayerType: LayerType,
      targetLayerType: LayerType
    })
  });
}

function FillAttributeDiff(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>,
  layerIdsToAttributes: Record<string, string[]>
) {
  return z.object({
    type: z.literal('fill-attribute'),
    layerId: layerIdSchema,
    payload: z.object({
      attribute: makeAttrsSchema(layerIdsToAttributes)
    })
  });
}

function FillColorDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('fill-color'),
    layerId: layerIdSchema,
    payload: z.object({
      color: z.string()
    })
  });
}

function FillColorSchemeDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('fill-color-scheme'),
    layerId: layerIdSchema,
    payload: z.object({
      scheme: z.union([
        z.literal('schemeBlues'),
        z.literal('schemeGreens'),
        z.literal('schemeGreys'),
        z.literal('schemeOranges'),
        z.literal('schemePurples'),
        z.literal('schemeReds'),
        z.literal('schemeBuGn'),
        z.literal('schemeBuPu'),
        z.literal('schemeGnBu'),
        z.literal('schemeOrRd'),
        z.literal('schemePuBuGn'),
        z.literal('schemePuBu'),
        z.literal('schemePuRd'),
        z.literal('schemeRdPu'),
        z.literal('schemeYlGnBu'),
        z.literal('schemeYlGn'),
        z.literal('schemeYlOrBr'),
        z.literal('schemeYlOrRd'),
        z.literal('schemeBrBG'),
        z.literal('schemePRGn'),
        z.literal('schemePiYG'),
        z.literal('schemePuOr'),
        z.literal('schemeRdBu'),
        z.literal('schemeRdGy'),
        z.literal('schemeRdYlBu'),
        z.literal('schemeRdYlGn'),
        z.literal('schemeSpectral'),
        z.literal('schemeCategory10'),
        z.literal('schemeAccent'),
        z.literal('schemeDark2'),
        z.literal('schemeObservable10'),
        z.literal('schemePaired'),
        z.literal('schemePastel1'),
        z.literal('schemePastel2'),
        z.literal('schemeSet1'),
        z.literal('schemeSet2'),
        z.literal('schemeSet3'),
        z.literal('schemeTableau10')
      ])
    })
  });
}

function FillColorSchemeDirectionDiff(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>
) {
  return z.object({
    type: z.literal('fill-color-scheme-direction'),
    layerId: layerIdSchema,
    payload: z.object({
      direction: z.union([z.literal('Forward'), z.literal('Reverse')])
    })
  });
}

const ClassificationMethod = z.union([
  z.literal('Quantile'),
  z.literal('Equal Interval'),
  z.literal('Jenks'),
  z.literal('Manual')
]);

function FillClassificationMethodDiff(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>
) {
  return z.object({
    type: z.literal('fill-classification-method'),
    layerId: layerIdSchema,
    payload: z.object({
      method: ClassificationMethod
    })
  });
}

function FillStepCountDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('fill-step-count'),
    layerId: layerIdSchema,
    payload: z.object({
      count: z.number().min(3).max(9)
    })
  });
}

function FillStepValueDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('fill-step-value'),
    layerId: layerIdSchema,
    payload: z.object({
      step: z.number().min(0),
      value: z.number()
    })
  });
}

const VisualizationType = z.union([
  z.literal('Quantitative'),
  z.literal('Categorical'),
  z.literal('Constant')
]);

function FillVisualizationTypeDiff(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>
) {
  return z.object({
    type: z.literal('fill-visualization-type'),
    layerId: layerIdSchema,
    payload: z.object({
      visualizationType: VisualizationType
    })
  });
}

function FillOpacityDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('fill-opacity'),
    layerId: layerIdSchema,
    payload: z.object({
      opacity: z.number().min(0).max(1)
    })
  });
}

function AddFillDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('add-fill'),
    layerId: layerIdSchema,
    payload: z.object({})
  });
}

function RemoveFillDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('remove-fill'),
    layerId: layerIdSchema,
    payload: z.object({})
  });
}

function StrokeColorDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('stroke-color'),
    layerId: layerIdSchema,
    payload: z.object({
      color: z.string()
    })
  });
}

function StrokeWidthDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('stroke-width'),
    layerId: layerIdSchema,
    payload: z.object({
      strokeWidth: z.number().min(0)
    })
  });
}

function StrokeOpacityDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('stroke-opacity'),
    layerId: layerIdSchema,
    payload: z.object({
      opacity: z.number().min(0).max(1)
    })
  });
}

function AddStrokeDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('add-stroke'),
    layerId: layerIdSchema,
    payload: z.object({})
  });
}

function RemoveStrokeDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('remove-stroke'),
    layerId: layerIdSchema,
    payload: z.object({})
  });
}

function SizeAttributeDiff(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>,
  layerIdsToAttributes: Record<string, string[]>
) {
  return z.object({
    type: z.literal('size-attribute'),
    layerId: layerIdSchema,
    payload: z.object({
      attribute: makeAttrsSchema(layerIdsToAttributes)
    })
  });
}

function SizeDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('size'),
    layerId: layerIdSchema,
    payload: z.object({
      size: z.number().min(0)
    })
  });
}

function MinSizeDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('min-size'),
    layerId: layerIdSchema,
    payload: z.object({
      minSize: z.number().min(0)
    })
  });
}

function MaxSizeDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('max-size'),
    layerId: layerIdSchema,
    payload: z.object({
      maxSize: z.number().min(0)
    })
  });
}

function DotValueDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('dot-value'),
    layerId: layerIdSchema,
    payload: z.object({ value: z.number().min(0) })
  });
}

function DotAttributeDiff(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>,
  layerIdsToAttributes: Record<string, string[]>
) {
  return z.object({
    type: z.literal('dot-attribute'),
    layerId: layerIdSchema,
    payload: z.object({ attribute: makeAttrsSchema(layerIdsToAttributes) })
  });
}

function HeatmapOpacityDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('heatmap-opacity'),
    layerId: layerIdSchema,
    payload: z.object({ opacity: z.number().min(0).max(1) })
  });
}

function HeatmapRadiusDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('heatmap-radius'),
    layerId: layerIdSchema,
    payload: z.object({ radius: z.number().min(0) })
  });
}

function HeatmapRampDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('heatmap-ramp'),
    layerId: layerIdSchema,
    payload: z.object({
      ramp: z.union([
        z.literal('Cividis'),
        z.literal('Viridis'),
        z.literal('Inferno'),
        z.literal('Magma'),
        z.literal('Plasma'),
        z.literal('Warm'),
        z.literal('Cool'),
        z.literal('CubehelixDefault'),
        z.literal('Turbo'),
        z.literal('Spectral'),
        z.literal('Rainbow'),
        z.literal('Sinebow')
      ])
    })
  });
}

function HeatmapRampDirectionDiff(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>
) {
  return z.object({
    type: z.literal('heatmap-ramp-direction'),
    layerId: layerIdSchema,
    payload: z.object({
      direction: z.union([z.literal('Forward'), z.literal('Reverse')])
    })
  });
}

function HeatmapWeightTypeDiff(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>
) {
  return z.object({
    type: z.literal('heatmap-weight-type'),
    layerId: layerIdSchema,
    payload: z.object({
      weightType: z.union([z.literal('Constant'), z.literal('Quantitative')])
    })
  });
}

function HeatmapWeightAttributeDiff(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>,
  layerIdsToAttributes: Record<string, string[]>
) {
  return z.object({
    type: z.literal('heatmap-weight-attribute'),
    layerId: layerIdSchema,
    payload: z.object({
      weightAttribute: makeAttrsSchema(layerIdsToAttributes)
    })
  });
}

function HeatmapWeightMinDiff(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>
) {
  return z.object({
    type: z.literal('heatmap-weight-min'),
    layerId: layerIdSchema,
    payload: z.object({
      min: z.number()
    })
  });
}

function HeatmapWeightMaxDiff(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>
) {
  return z.object({
    type: z.literal('heatmap-weight-max'),
    layerId: layerIdSchema,
    payload: z.object({
      max: z.number()
    })
  });
}

function HeatmapWeightValueDiff(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>
) {
  return z.object({
    type: z.literal('heatmap-weight-value'),
    layerId: layerIdSchema,
    payload: z.object({ value: z.number().min(0) })
  });
}

function LayerVisibilityDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('layer-visibility'),
    layerId: layerIdSchema,
    payload: z.object({ visible: z.boolean() })
  });
}

function LayerTooltipVisibilityDiff(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>
) {
  return z.object({
    type: z.literal('layer-tooltip-visibility'),
    layerId: layerIdSchema,
    payload: z.object({ visible: z.boolean() })
  });
}

function AddLayerDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('add-layer'),
    layerId: layerIdSchema,
    payload: z.object({
      type: z.literal('api'),
      displayName: z.string(),
      url: z.string()
    })
  });
}

function RemoveLayerDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('remove-layer'),
    layerId: layerIdSchema,
    payload: z.object({})
  });
}

function RenameLayerDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('rename-layer'),
    layerId: layerIdSchema,
    payload: z.object({ displayName: z.string() })
  });
}

const Basemap = z.union(
  Object.entries(BASEMAPS).flatMap(([provider, basemaps]) => {
    return basemaps.map((basemap) =>
      z.object({
        provider: z.literal(provider),
        url: z.literal(TILE_URLS[provider as BasemapProvider](basemap.tileId))
      })
    );
  })
);

const BasemapDiff = z.object({
  type: z.literal('basemap'),
  payload: Basemap
});

const ZoomDiff = z.object({
  type: z.literal('zoom'),
  payload: z.object({ zoom: z.number().min(0).max(22) })
});

const CenterDiff = z.object({
  type: z.literal('center'),
  payload: z.object({
    center: z.object({
      lng: z.number().min(-180).max(180),
      lat: z.number().min(-90).max(90)
    })
  })
});

const ProjectionDiff = z.object({
  type: z.literal('projection'),
  payload: z.object({
    projection: z.union([z.literal('mercator'), z.literal('globe')])
  })
});

function UnknownDiff(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('unknown'),
    layerId: layerIdSchema,
    payload: z.object({})
  });
}

function makeSchema(
  layerIds: string[],
  layerIdsToAttributes: Record<string, string[]>
) {
  const layerIdSchema = makeLayerIdSchema(layerIds);

  return z.object({
    diffs: z.array(
      z.discriminatedUnion('type', [
        LayerTypeDiff(layerIdSchema),
        FillAttributeDiff(layerIdSchema, layerIdsToAttributes),
        FillColorDiff(layerIdSchema),
        FillColorSchemeDiff(layerIdSchema),
        FillColorSchemeDirectionDiff(layerIdSchema),
        FillClassificationMethodDiff(layerIdSchema),
        FillStepCountDiff(layerIdSchema),
        FillStepValueDiff(layerIdSchema),
        FillVisualizationTypeDiff(layerIdSchema),
        FillOpacityDiff(layerIdSchema),
        AddFillDiff(layerIdSchema),
        RemoveFillDiff(layerIdSchema),
        StrokeColorDiff(layerIdSchema),
        StrokeWidthDiff(layerIdSchema),
        StrokeOpacityDiff(layerIdSchema),
        AddStrokeDiff(layerIdSchema),
        RemoveStrokeDiff(layerIdSchema),
        SizeAttributeDiff(layerIdSchema, layerIdsToAttributes),
        SizeDiff(layerIdSchema),
        MinSizeDiff(layerIdSchema),
        MaxSizeDiff(layerIdSchema),
        DotValueDiff(layerIdSchema),
        DotAttributeDiff(layerIdSchema, layerIdsToAttributes),
        HeatmapOpacityDiff(layerIdSchema),
        HeatmapRadiusDiff(layerIdSchema),
        HeatmapRampDiff(layerIdSchema),
        HeatmapRampDirectionDiff(layerIdSchema),
        HeatmapWeightTypeDiff(layerIdSchema),
        HeatmapWeightAttributeDiff(layerIdSchema, layerIdsToAttributes),
        HeatmapWeightMinDiff(layerIdSchema),
        HeatmapWeightMaxDiff(layerIdSchema),
        HeatmapWeightValueDiff(layerIdSchema),
        LayerVisibilityDiff(layerIdSchema),
        LayerTooltipVisibilityDiff(layerIdSchema),
        AddLayerDiff(layerIdSchema),
        RemoveLayerDiff(layerIdSchema),
        RenameLayerDiff(layerIdSchema),
        BasemapDiff,
        ZoomDiff,
        CenterDiff,
        ProjectionDiff,
        UnknownDiff(layerIdSchema)
      ])
    )
  });
}
