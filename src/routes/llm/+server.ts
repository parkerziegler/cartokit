import { json, error } from '@sveltejs/kit';
import OpenAI from 'openai';
import type { ChatCompletionParseParams } from 'openai/resources/chat/completions';
import { z } from 'zod';

import { OPENAI_API_KEY } from '$env/static/private';
import type { RequestHandler } from './$types';

import { connectToMongoDB } from '$lib/db';
import type { LayerType } from '$lib/types';

interface PromptDoc {
  userId: string;
  prompt: string;
  diffs: unknown[];
  timestamp: string;
}

/**
 * Persist the user's prompt and the diffs generated by the OpenAI API to
 * MongoDB for later analysis.
 *
 * @param userId – The ID of the user who made the request.
 * @param prompt – The user's prompt, sent to the OpenAI API.
 * @param diffs – The array of diffs generated by the OpenAI API.
 * @returns – The document that was saved to MongoDB.
 */
async function savePrompt(
  userId: string,
  prompt: string,
  diffs: unknown[]
): Promise<PromptDoc> {
  const db = connectToMongoDB();
  const collection = db.collection('prompts');

  const doc = {
    userId,
    prompt,
    diffs,
    timestamp: new Date().toISOString()
  };

  try {
    await collection.insertOne(doc);

    return doc;
  } catch (error) {
    throw new Error(`Failed to save prompt: ${error}`);
  }
}

// Initialize the OpenAI client.
const openai = new OpenAI({
  apiKey: OPENAI_API_KEY!
});

/**
 * The main function that handles the POST request to the /llm endpoint. This
 * function receives a prompt from a user and sends it to the OpenAI API, re-
 * turning the generated diffs as a JSON response. In addition, we save off
 * the prompt and diffs to MongoDB for later analysis.
 */
export const POST = (async ({ request }) => {
  const { prompt, layerIds, layerIdsToAttributes, userId } =
    await request.json();

  const schema = makeSchema(layerIds, layerIdsToAttributes);

  try {
    const completion = await openai.chat.completions.parse<
      ChatCompletionParseParams,
      z.infer<typeof schema>
    >({
      model: 'gpt-5',
      messages: [
        {
          role: 'system',
          content:
            'Generate zero or more updates to the map visualization. Choose the "unknown" update if you cannot easily determine the type of update based on the prompt.'
        },
        { role: 'user', content: prompt }
      ],
      response_format: {
        type: 'json_schema',
        json_schema: {
          name: 'diffs',
          strict: true,
          schema: z.toJSONSchema(schema, {
            target: 'draft-7'
          })
        }
      }
    });

    const result = completion.choices[0].message.parsed;

    if (result) {
      const diffs = result.diffs;

      await savePrompt(userId, prompt, diffs);
    }

    return json(result);
  } catch (err) {
    console.error(err);

    return error(500, {
      message: 'Internal server error'
    });
  }
}) satisfies RequestHandler;

/**
 * Construct the schema for the layerId field for a diff object. We want con-
 * strained decoding responses from the OpenAI API to only target existing
 * layers on the map.
 *
 * @param layerIds – An array of the current layer IDs on the map.
 * @returns – A Zod schema for the layerId field in a diff object.
 */
function makeLayerIdSchema(layerIds: string[]) {
  return layerIds.length > 1
    ? z.union([
        z.literal(layerIds[0]),
        z.literal(layerIds[1]),
        ...layerIds.slice(2).map((id) => z.literal(id))
      ])
    : z.literal(layerIds[0]);
}

const LayerType = z.union([
  z.literal('Point'),
  z.literal('Proportional Symbol'),
  z.literal('Line'),
  z.literal('Polygon'),
  z.literal('Choropleth'),
  z.literal('Dot Density'),
  z.literal('Heatmap')
]);

function LayerTypeUpdate(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('layer-type'),
    layerId: layerIdSchema,
    payload: z.object({
      layerType: LayerType
    })
  });
}

function AttributeUpdate(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>,
  layerIdsToAttributes: Record<string, string[]>
) {
  const attrs = Object.values(layerIdsToAttributes).flat();

  return z.object({
    type: z.literal('attribute'),
    layerId: layerIdSchema,
    payload: z.object({
      attribute: z.union([
        z.literal(attrs[0]),
        z.literal(attrs[1]),
        ...attrs.slice(2).map((attr) => z.literal(attr))
      ]),
      channel: z.union([
        z.literal('fill'),
        z.literal('size'),
        z.literal('dots')
      ])
    })
  });
}

function FillUpdate(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('fill'),
    layerId: layerIdSchema,
    payload: z.object({
      color: z.string()
    })
  });
}

function FillOpacityUpdate(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('fill-opacity'),
    layerId: layerIdSchema,
    payload: z.object({
      opacity: z.number().min(0).max(1)
    })
  });
}

function AddFillUpdate(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('add-fill'),
    layerId: layerIdSchema,
    payload: z.object({})
  });
}

function RemoveFillUpdate(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('remove-fill'),
    layerId: layerIdSchema,
    payload: z.object({})
  });
}

function StrokeUpdate(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('stroke'),
    layerId: layerIdSchema,
    payload: z.object({
      width: z.number().min(0),
      color: z.string()
    })
  });
}

function StrokeWidthUpdate(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('stroke-width'),
    layerId: layerIdSchema,
    payload: z.object({
      strokeWidth: z.number().min(0)
    })
  });
}

function StrokeOpacityUpdate(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('stroke-opacity'),
    layerId: layerIdSchema,
    payload: z.object({
      opacity: z.number().min(0).max(1)
    })
  });
}

function AddStrokeUpdate(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('add-stroke'),
    layerId: layerIdSchema,
    payload: z.object({})
  });
}

function RemoveStrokeUpdate(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('remove-stroke'),
    layerId: layerIdSchema,
    payload: z.object({})
  });
}

function PointSizeUpdate(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('point-size'),
    layerId: layerIdSchema,
    payload: z.object({
      size: z.number().min(0)
    })
  });
}

const ClassificationMethod = z.union([
  z.literal('Quantile'),
  z.literal('Equal Interval'),
  z.literal('Jenks'),
  z.literal('Manual')
]);

function ClassificationMethodUpdate(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>
) {
  return z.object({
    type: z.literal('classification-method'),
    layerId: layerIdSchema,
    payload: z.object({
      method: ClassificationMethod
    })
  });
}

function ColorSchemeUpdate(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('color-scheme'),
    layerId: layerIdSchema,
    payload: z.object({
      scheme: z.union([
        z.literal('schemeBlues'),
        z.literal('schemeGreens'),
        z.literal('schemeGreys'),
        z.literal('schemeOranges'),
        z.literal('schemePurples'),
        z.literal('schemeReds'),
        z.literal('schemeBuGn'),
        z.literal('schemeBuPu'),
        z.literal('schemeGnBu'),
        z.literal('schemeOrRd'),
        z.literal('schemePuBuGn'),
        z.literal('schemePuBu'),
        z.literal('schemePuRd'),
        z.literal('schemeRdPu'),
        z.literal('schemeYlGnBu'),
        z.literal('schemeYlGn'),
        z.literal('schemeYlOrBr'),
        z.literal('schemeYlOrRd'),
        z.literal('schemeBrBG'),
        z.literal('schemePRGn'),
        z.literal('schemePiYG'),
        z.literal('schemePuOr'),
        z.literal('schemeRdBu'),
        z.literal('schemeRdGy'),
        z.literal('schemeRdYlBu'),
        z.literal('schemeRdYlGn'),
        z.literal('schemeSpectral'),
        z.literal('schemeCategory10'),
        z.literal('schemeAccent'),
        z.literal('schemeDark2'),
        z.literal('schemeObservable10'),
        z.literal('schemePaired'),
        z.literal('schemePastel1'),
        z.literal('schemePastel2'),
        z.literal('schemeSet1'),
        z.literal('schemeSet2'),
        z.literal('schemeSet3'),
        z.literal('schemeTableau10')
      ])
    })
  });
}

function ColorSchemeDirectionUpdate(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>
) {
  return z.object({
    type: z.literal('color-scheme-direction'),
    layerId: layerIdSchema,
    payload: z.object({
      direction: z.union([z.literal('Forward'), z.literal('Reverse')])
    })
  });
}

function ColorCountUpdate(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('color-count'),
    layerId: layerIdSchema,
    payload: z.object({
      count: z.number().min(3).max(9)
    })
  });
}

function ColorThresholdUpdate(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>
) {
  return z.object({
    type: z.literal('color-threshold'),
    layerId: layerIdSchema,
    payload: z.object({
      index: z.number().min(0),
      threshold: z.number()
    })
  });
}

function SizeUpdate(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('size'),
    layerId: layerIdSchema,
    payload: z.object({
      min: z.number().min(0).nullable(),
      max: z.number().min(0).nullable()
    })
  });
}

function DotValueUpdate(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('dot-value'),
    layerId: layerIdSchema,
    payload: z.object({
      value: z.number().min(0.000001)
    })
  });
}

const VisualizationType = z.union([
  z.literal('Quantitative'),
  z.literal('Categorical'),
  z.literal('Constant')
]);

function VisualizationTypeUpdate(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>
) {
  return z.object({
    type: z.literal('visualization-type'),
    layerId: layerIdSchema,
    payload: z.object({
      visualizationType: VisualizationType
    })
  });
}

function HeatmapOpacityUpdate(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>
) {
  return z.object({
    type: z.literal('heatmap-opacity'),
    layerId: layerIdSchema,
    payload: z.object({ opacity: z.number().min(0).max(1) })
  });
}

function HeatmapRadiusUpdate(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('heatmap-radius'),
    layerId: layerIdSchema,
    payload: z.object({ radius: z.number().min(0) })
  });
}

function HeatmapRampUpdate(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('heatmap-ramp'),
    layerId: layerIdSchema,
    payload: z.object({
      ramp: z.union([
        z.literal('Cividis'),
        z.literal('Viridis'),
        z.literal('Inferno'),
        z.literal('Magma'),
        z.literal('Plasma'),
        z.literal('Warm'),
        z.literal('Cool'),
        z.literal('CubehelixDefault'),
        z.literal('Turbo'),
        z.literal('Spectral'),
        z.literal('Rainbow'),
        z.literal('Sinebow')
      ])
    })
  });
}

function HeatmapRampDirectionUpdate(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>
) {
  return z.object({
    type: z.literal('heatmap-ramp-direction'),
    layerId: layerIdSchema,
    payload: z.object({
      direction: z.union([z.literal('Forward'), z.literal('Reverse')])
    })
  });
}

function HeatmapWeightTypeUpdate(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>
) {
  return z.object({
    type: z.literal('heatmap-weight-type'),
    layerId: layerIdSchema,
    payload: z.object({
      weightType: z.union([z.literal('Constant'), z.literal('Quantitative')])
    })
  });
}

function HeatmapWeightAttributeUpdate(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>,
  layerIdsToAttributes: Record<string, string[]>
) {
  const attrs = Object.values(layerIdsToAttributes).flat();

  return z.object({
    type: z.literal('heatmap-weight-attribute'),
    layerId: layerIdSchema,
    payload: z.object({
      attribute: z.union([
        z.literal(attrs[0]),
        z.literal(attrs[1]),
        ...attrs.slice(2).map((attr) => z.literal(attr))
      ])
    })
  });
}

function HeatmapWeightBoundsUpdate(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>
) {
  return z.object({
    type: z.literal('heatmap-weight-bounds'),
    layerId: layerIdSchema,
    payload: z.object({
      min: z.number().nullable(),
      max: z.number().nullable()
    })
  });
}

function HeatmapWeightValueUpdate(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>
) {
  return z.object({
    type: z.literal('heatmap-weight-value'),
    layerId: layerIdSchema,
    payload: z.object({ value: z.number().min(0) })
  });
}

const LayerVisibility = z.union([z.literal('visible'), z.literal('hidden')]);

function LayerVisibilityUpdate(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>
) {
  return z.object({
    type: z.literal('layer-visibility'),
    layerId: layerIdSchema,
    payload: z.object({ visibility: LayerVisibility })
  });
}

function LayerTooltipVisibilityUpdate(
  layerIdSchema: z.infer<typeof makeLayerIdSchema>
) {
  return z.object({
    type: z.literal('layer-tooltip-visibility'),
    layerId: layerIdSchema,
    payload: z.object({ visible: z.boolean() })
  });
}

function RemoveLayerUpdate(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('remove-layer'),
    layerId: layerIdSchema,
    payload: z.object({})
  });
}

function RenameLayerUpdate(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('rename-layer'),
    layerId: layerIdSchema,
    payload: z.object({ displayName: z.string() })
  });
}

function UnknownUpdate(layerIdSchema: z.infer<typeof makeLayerIdSchema>) {
  return z.object({
    type: z.literal('unknown'),
    layerId: layerIdSchema,
    payload: z.object({})
  });
}

function makeSchema(
  layerIds: string[],
  layerIdsToAttributes: Record<string, string[]>
) {
  const layerIdSchema = makeLayerIdSchema(layerIds);

  return z.object({
    diffs: z.array(
      z.discriminatedUnion('type', [
        LayerTypeUpdate(layerIdSchema),
        AttributeUpdate(layerIdSchema, layerIdsToAttributes),
        FillUpdate(layerIdSchema),
        FillOpacityUpdate(layerIdSchema),
        AddFillUpdate(layerIdSchema),
        RemoveFillUpdate(layerIdSchema),
        StrokeUpdate(layerIdSchema),
        StrokeWidthUpdate(layerIdSchema),
        StrokeOpacityUpdate(layerIdSchema),
        AddStrokeUpdate(layerIdSchema),
        RemoveStrokeUpdate(layerIdSchema),
        PointSizeUpdate(layerIdSchema),
        ClassificationMethodUpdate(layerIdSchema),
        ColorSchemeUpdate(layerIdSchema),
        ColorSchemeDirectionUpdate(layerIdSchema),
        ColorCountUpdate(layerIdSchema),
        ColorThresholdUpdate(layerIdSchema),
        SizeUpdate(layerIdSchema),
        DotValueUpdate(layerIdSchema),
        VisualizationTypeUpdate(layerIdSchema),
        HeatmapOpacityUpdate(layerIdSchema),
        HeatmapRadiusUpdate(layerIdSchema),
        HeatmapRampUpdate(layerIdSchema),
        HeatmapRampDirectionUpdate(layerIdSchema),
        HeatmapWeightTypeUpdate(layerIdSchema),
        HeatmapWeightAttributeUpdate(layerIdSchema, layerIdsToAttributes),
        HeatmapWeightBoundsUpdate(layerIdSchema),
        HeatmapWeightValueUpdate(layerIdSchema),
        LayerVisibilityUpdate(layerIdSchema),
        LayerTooltipVisibilityUpdate(layerIdSchema),
        RemoveLayerUpdate(layerIdSchema),
        RenameLayerUpdate(layerIdSchema),
        UnknownUpdate(layerIdSchema)
      ])
    )
  });
}
